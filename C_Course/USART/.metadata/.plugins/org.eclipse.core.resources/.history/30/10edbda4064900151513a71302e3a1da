/////////////////////////////////////////////////////////////////////////
///	\file usart2.c
///	\brief STM32 serial2 MCU hardware interface layer. to maintain
///	code portability, the hardware related code is split from the main logic.
///
///	Author: Ronald Sousa (Opticalworm)
/////////////////////////////////////////////////////////////////////////
#include "MCU/usart2.h"

/////////////////////////////////////////////////////////////////////////
/// \brief enable 16x oversampling. Used to reduce the baudrate calculation
/// error.
/////////////////////////////////////////////////////////////////////////
//#define USART_OVER_SAMPLE_16

/////////////////////////////////////////////////////////////////////////
///	\brief	Set usart baudrate. can be called at any time.
///
///	\param baud the desire baudrate
///
///	\note setting baudrate will effect any data currently been sent.susb
///		make sure that you check that the write buffer is empty
/////////////////////////////////////////////////////////////////////////
void Usart2_Setbaud(uint32_t baud)
{
    uint_fast8_t WasUsartEnable = FALSE;
    uint16_t BaudrateTemp;

    // make sure that we preserve the usart enable state.
    if(USART_CR1_UE & USART2->CR1)
    {
        WasUsartEnable = TRUE;
        USART2->CR1 &= ~(USART_CR1_UE);         // turn off usart.
    }

#ifdef USART_OVER_SAMPLE_16
    // oversample 16x
    BaudrateTemp = (SystemCoreClock) /(baud);
#else
    // oversample is 8x

    //calculate our baudrate
    BaudrateTemp = (2 * SystemCoreClock) /(baud);
    // right shift once bits BaudrateTemp[2:0] and set BaudrateTemp[3] to zero. leave the rest of the bits as if
    BaudrateTemp = ((BaudrateTemp & 0xFFF0) | ((BaudrateTemp >> 1) & 0x0007));

#endif

    USART2->BRR =  BaudrateTemp;


    if(WasUsartEnable)
    {
        USART2->CR1 |= USART_CR1_UE;
    }
}

/////////////////////////////////////////////////////////////////////////
/// \brief  setup the usart hardware
///
/// \param baud the desire baudrate
/////////////////////////////////////////////////////////////////////////
void Usart2_Init(uint32_t baud)
{
    USART2->CR1 = 0;

    // make sure that the IO clock is enabled
    RCC->AHBENR |= ((uint32_t)1<<17);

    // Change PA2 and PA3 port function to their alternate mode
    GPIOA->MODER &= ~((uint32_t)0x3 << 4) | ~((uint32_t)0x3 << 6);    // clear the related bits before we set them. Comment the next call will set all bits.
    GPIOA->MODER |= ((uint32_t)2 << 4) | ((uint32_t)2 << 6);            // Set both PA2 and PA3 to there alternate functions. PA2 = default TX. PA3 = default RX

    GPIOA->AFR[0] &= ~((uint32_t)0xF << 12) | ~((uint32_t)0xF << 8);    // clear the related bits before we set them
    GPIOA->AFR[0] |= ((uint32_t)1 << 12) | ((uint32_t)1 << 8);          // Select TX and RX alternate functions

    RCC->APB1ENR |= ((uint32_t)1<<17);                                  // USART2 peripheral clock

    Usart2_Setbaud(baud);                                                // set baudrate

    USART2->CR1 = USART_CR1_UE | USART_CR1_OVER8 | USART_CR1_RE;
    USART2->CR1  |= USART_CR1_TE ;
}

/////////////////////////////////////////////////////////////////////////
///	\brief	you can use this function to check if the write buffer is
///	empty and ready for new data
///
///	\param destination pointer to return the read byte
///	\return TRUE = Busy else ready. else false
/////////////////////////////////////////////////////////////////////////
uint_fast8_t Usart2_IsWriteBusy(void)
{
	uint_fast8_t ReturnState = TRUE;

     if(USART2->ISR & USART_ISR_TXE)
     {
         ReturnState = FALSE;
     }

	return ReturnState;
}

/////////////////////////////////////////////////////////////////////////
///	\brief transmit a single byte. this is a blocking function
///
///	\param source byte to write
///
/// \sa Usart2_IsWriteBusy
/////////////////////////////////////////////////////////////////////////
void Usart2_WriteByte(uint8_t source)
{

    while( Usart2_IsWriteBusy() );

    USART2->TDR = (uint32_t)source;
}

/////////////////////////////////////////////////////////////////////////
/// \brief  Usart write string. this is a blocking function
///
/// \param source pointer to the string which is null terminated.
///
/// \sa Usart2_IsWriteBusy
/////////////////////////////////////////////////////////////////////////
void Usart2_WriteString(uint8_t * source)
{
    while(*source)
    {
        Usart2_WriteByte(*source);
        source++;
    }
}

/////////////////////////////////////////////////////////////////////////
///	\brief	Uart read single byte
///
///	\param destination pointer to return the read byte
///	\return FALSE on success else TRUE
/////////////////////////////////////////////////////////////////////////
uint_fast8_t Usart2_ReadByte(uint8_t * destination)
{
	uint_fast8_t ReturnState = TRUE;

	///	\todo Write code here that reads one byte from usart and
	///	set ReturnState TRUE of false depending
	///	if it was successful.

	return ReturnState;
}
